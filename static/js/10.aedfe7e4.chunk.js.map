{"version":3,"sources":["hooks/useChapter.tsx","chapters/chapter2/chapter2.mp4","chapters/chapter2/part1/Part1.tsx","chapters/chapter2/Chapter2.tsx"],"names":["useChapter","ref","needsCamera","useEffect","store","setState","isCameraEnabled","play","useCallback","current","pause","rewind","currentTime","getIsPlaying","paused","ended","readyState","getProgress","duration","setProgress","progress","seekTimeDelta","delta","target","clippedTarget","Math","min","max","seekTime","time","setMuted","isMuted","muted","setVolume","volume","getMuted","onClick","updateStore","chapter","intention","video","addEventListener","removeEventListener","undefined","Part1","maskType","hasFirstPrediction","useHasFirstPrediction","webcam","useStore","state","webcamHTMLElement","aspect","webcamAspect","style","position","width","height","orthographic","StaticBackground","WorldOffset","targetAspect","Mask","track","RainbowVomit","Chapter2","useRef","useState","part","setPart","ontimeupdate","event","nativeEvent","seconds","round","onTimeUpdate","Box","align","overflow","boxSizing","outline","src","videoSrc"],"mappings":"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","file":"static/js/10.aedfe7e4.chunk.js","sourcesContent":["import { useCallback, useEffect } from \"react\";\nimport { store } from \"../store/store\";\n\nexport function useChapter(\n  ref: React.RefObject<HTMLAudioElement | HTMLVideoElement>,\n  needsCamera: boolean\n) {\n  useEffect(() => {\n    store.setState({ isCameraEnabled: needsCamera });\n  }, [needsCamera]);\n\n  const play = useCallback(() => ref.current?.play(), [ref]);\n  const pause = useCallback(() => ref.current?.pause(), [ref]);\n  const rewind = useCallback(() => {\n    if (ref.current) ref.current.currentTime = 0;\n  }, [ref]);\n  const getIsPlaying = useCallback(() => {\n    if (!ref.current) return false;\n    return !!(\n      ref.current.currentTime > 0 &&\n      !ref.current.paused &&\n      !ref.current.ended &&\n      ref.current.readyState > 2\n    );\n  }, [ref]);\n\n  const getProgress = useCallback(() => {\n    if (!ref.current) return 0;\n    return ref.current.currentTime / ref.current.duration;\n  }, [ref]);\n\n  const setProgress = useCallback(\n    (progress: number) => {\n      if (!ref.current) return;\n      ref.current.currentTime = progress * ref.current.duration;\n    },\n    [ref]\n  );\n\n  const seekTimeDelta = useCallback(\n    (delta: number) => {\n      if (!ref.current) return;\n      const target = ref.current.currentTime + delta;\n      const clippedTarget = Math.min(Math.max(0, target), ref.current.duration);\n      ref.current.currentTime = clippedTarget;\n    },\n    [ref]\n  );\n  const seekTime = useCallback(\n    (time: number) => {\n      if (!ref.current) return;\n      const target = time;\n      const clippedTarget = Math.min(Math.max(0, target), ref.current.duration);\n      ref.current.currentTime = clippedTarget;\n    },\n    [ref]\n  );\n\n  const setMuted = useCallback(\n    (isMuted: boolean) => {\n      if (!ref.current) return;\n      ref.current.muted = isMuted;\n    },\n    [ref]\n  );\n  const setVolume = useCallback(\n    (volume: number) => {\n      if (!ref.current) return;\n      ref.current.volume = volume;\n    },\n    [ref]\n  );\n\n  const getMuted = useCallback(() => {\n    if (!ref.current) return false;\n    return ref.current.muted;\n  }, [ref]);\n  const onClick = useCallback(\n    () => (getIsPlaying() ? pause() : play()),\n    [getIsPlaying, pause, play]\n  );\n\n  useEffect(() => {\n    const updateStore = () => {\n      return store.setState({\n        chapter: {\n          play,\n          pause,\n          rewind,\n          getIsPlaying,\n          getProgress,\n          setProgress,\n          seekTimeDelta,\n          seekTime,\n          setMuted,\n          setVolume,\n          isMuted: getMuted(),\n          progress: getProgress(),\n          intention: getIsPlaying() ? \"PLAY\" : \"PAUSE\",\n        },\n      });\n    };\n\n    const video = ref.current;\n\n    ref.current?.addEventListener(\"click\", onClick);\n    ref.current?.addEventListener(\"playing\", updateStore);\n    ref.current?.addEventListener(\"pause\", updateStore);\n    ref.current?.addEventListener(\"volumechange\", updateStore);\n    ref.current?.addEventListener(\"timeupdate\", updateStore);\n    updateStore();\n    return () => {\n      video?.removeEventListener(\"click\", onClick);\n      video?.removeEventListener(\"play\", updateStore);\n      video?.removeEventListener(\"pause\", updateStore);\n      video?.removeEventListener(\"timeupdate\", updateStore);\n      store.setState({ chapter: undefined });\n    };\n  }, [\n    getIsPlaying,\n    pause,\n    play,\n    getProgress,\n    rewind,\n    setProgress,\n    seekTimeDelta,\n    setMuted,\n    getMuted,\n    ref,\n    onClick,\n    seekTime,\n    setVolume,\n  ]);\n}\n","export default __webpack_public_path__ + \"static/media/chapter2.2bd44c1d.mp4\";","import { Canvas } from \"@react-three/fiber\";\nimport React from \"react\";\nimport { useHasFirstPrediction } from \"src/hooks/useHasFirstPrediction\";\nimport { useStore } from \"../../../store/store\";\nimport { Mask } from \"./Mask\";\nimport { RainbowVomit } from \"./RainbowVomit\";\nimport { StaticBackground } from \"./StaticBackground\";\nimport { WorldOffset } from \"./WorldOffset\";\n\nexport const Part1 = ({\n  maskType,\n}: {\n  maskType: \"video\" | \"brett\" | \"own\";\n}) => {\n  const hasFirstPrediction = useHasFirstPrediction();\n\n  const webcam = useStore((state) => state.webcamHTMLElement);\n  const aspect = useStore((state) => state.webcamAspect);\n\n  return (\n    <Canvas\n      style={{\n        position: \"absolute\",\n        width: \"100%\",\n        height: \"100%\",\n      }}\n      orthographic={false}\n    >\n      <StaticBackground></StaticBackground>\n      {hasFirstPrediction && aspect !== undefined && (\n        <>\n          <WorldOffset targetAspect={aspect}>\n            <Mask track=\"center\" maskType={maskType} webcam={webcam}></Mask>\n          </WorldOffset>\n          <RainbowVomit targetAspect={aspect} />\n        </>\n      )}\n    </Canvas>\n  );\n};\n","import { Box } from \"grommet\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { useChapter } from \"../../hooks/useChapter\";\nimport videoSrc from \"./chapter2.mp4\";\nimport { Part1 } from \"./part1/Part1\";\n\nexport default function Chapter2() {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useChapter(ref, true);\n\n  const [part, setPart] =\n    useState<\n      \"SCREEN_1_MASK_1\" | \"SCREEN_1_MASK_2\" | \"SCREEN_1_MASK_3\" | \"SCREEN_2\"\n    >(\"SCREEN_1_MASK_1\");\n\n  useEffect(() => {\n    if (!ref.current) return;\n    const video = ref.current;\n    const onTimeUpdate = ({ nativeEvent: event }: { nativeEvent: Event }) => {\n      const video = event.target as HTMLVideoElement;\n      const seconds = Math.round(video.currentTime);\n\n      if (seconds < 25) {\n        setPart(\"SCREEN_1_MASK_1\");\n      } else if (seconds < 28) {\n        setPart(\"SCREEN_1_MASK_2\");\n      } else if (seconds < 47) {\n        setPart(\"SCREEN_1_MASK_3\");\n      } else {\n        setPart(\"SCREEN_2\");\n      }\n    };\n\n    video.ontimeupdate = (event) => onTimeUpdate({ nativeEvent: event });\n  }, []);\n\n  const maskType =\n    part === \"SCREEN_1_MASK_1\"\n      ? \"video\"\n      : part === \"SCREEN_1_MASK_2\"\n      ? \"brett\"\n      : \"own\";\n\n  return (\n    <Box\n      style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}\n      align=\"center\"\n      overflow=\"hidden\"\n    >\n      {part !== \"SCREEN_2\" && <Part1 maskType={maskType} />}\n      <video\n        ref={ref}\n        style={{\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n        width=\"100%\"\n        height=\"100%\"\n        src={videoSrc}\n      ></video>\n    </Box>\n  );\n}\n"],"sourceRoot":""}