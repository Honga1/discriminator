{"version":3,"sources":["hooks/useChapter.tsx","pages/chapters/chapter3/useAnimationFrame.tsx","p2.mp4","pages/chapters/Chapter2.tsx","pages/chapters/chapter2/useAsyncMemo.tsx"],"names":["useChapter","ref","needsCamera","store","setState","isCameraEnabled","play","useCallback","current","pause","rewind","currentTime","getIsPlaying","paused","ended","readyState","getProgress","duration","setProgress","progress","seekTimeDelta","delta","target","clippedTarget","Math","min","max","onClick","useEffect","updateStore","chapter","intention","video","addEventListener","removeEventListener","undefined","useAnimationFrame","frameRate","callback","requestRef","useRef","timeoutRef","previousTimeRef","Date","now","frameInterval","animate","time","a","deltaTime","Promise","resolve","setTimeout","requestAnimationFrame","cancelAnimationFrame","clearTimeout","Dots","props","size","useThree","scale","width","height","position","frustumCulled","geometry","color","Rect","rectRef","transparent","opacity","Chapter2","webcamRef","useState","window","innerWidth","innerHeight","canvasWidth","canvasHeight","setCanvasSize","webcamStream","useStore","state","model","factory","deps","initial","val","setVal","cancel","promise","then","useAsyncMemo","facemesh","mediapipeFacemesh","shouldLoadIrisModel","maxFaces","useResizeObserver","videoDivWidth","videoDivHeight","srcObject","track","getVideoTracks","getSettings","videoAspect","HTMLMediaElement","HAVE_METADATA","estimateFaces","input","returnTensors","flipHorizontal","predictIrises","predictions","length","landmarks","scaledMesh","topLeft","boundingBox","bottomRight","positions3d","flatMap","index","x","y","videoWidth","videoHeight","setAttribute","BufferAttribute","Float32Array","centerX","centerY","setX","setY","Box","style","align","top","boxSizing","outline","hidden","transform","orthographic","src","videoSrc"],"mappings":"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","file":"static/js/7.b2af6a5b.chunk.js","sourcesContent":["import { useCallback, useEffect } from \"react\";\nimport { store } from \"../store/store\";\nimport { IMediaElement } from \"../IMediaElement\";\n\nexport function useChapter(\n  ref: React.RefObject<IMediaElement>,\n  needsCamera: boolean\n) {\n  store.setState({ isCameraEnabled: needsCamera });\n\n  const play = useCallback(() => ref.current?.play(), [ref]);\n  const pause = useCallback(() => ref.current?.pause(), [ref]);\n  const rewind = useCallback(() => {\n    if (ref.current) ref.current.currentTime = 0;\n  }, [ref]);\n  const getIsPlaying = useCallback(() => {\n    if (!ref.current) return false;\n    return !!(\n      ref.current.currentTime > 0 &&\n      !ref.current.paused &&\n      !ref.current.ended &&\n      ref.current.readyState > 2\n    );\n  }, [ref]);\n\n  const getProgress = useCallback(() => {\n    if (!ref.current) return 0;\n    return ref.current.currentTime / ref.current.duration;\n  }, [ref]);\n\n  const setProgress = useCallback(\n    (progress: number) => {\n      if (!ref.current) return;\n      ref.current.currentTime = progress * ref.current.duration;\n    },\n    [ref]\n  );\n\n  const seekTimeDelta = useCallback(\n    (delta: number) => {\n      if (!ref.current) return;\n      const target = ref.current.currentTime + delta;\n      const clippedTarget = Math.min(Math.max(0, target), ref.current.duration);\n      ref.current.currentTime = clippedTarget;\n    },\n    [ref]\n  );\n  const onClick = useCallback(() => (getIsPlaying() ? pause() : play()), [\n    getIsPlaying,\n    pause,\n    play,\n  ]);\n\n  useEffect(() => {\n    const updateStore = () => {\n      return store.setState({\n        chapter: {\n          play,\n          pause,\n          rewind,\n          getIsPlaying,\n          getProgress,\n          setProgress,\n          seekTimeDelta,\n          progress: getProgress(),\n          intention: getIsPlaying() ? \"PLAY\" : \"PAUSE\",\n        },\n      });\n    };\n\n    const video = ref.current;\n\n    ref.current?.addEventListener(\"click\", onClick);\n    ref.current?.addEventListener(\"playing\", updateStore);\n    ref.current?.addEventListener(\"pause\", updateStore);\n    ref.current?.addEventListener(\"timeupdate\", updateStore);\n    updateStore();\n    return () => {\n      video?.removeEventListener(\"click\", onClick);\n      video?.removeEventListener(\"play\", updateStore);\n      video?.removeEventListener(\"pause\", updateStore);\n      video?.removeEventListener(\"timeupdate\", updateStore);\n      store.setState({ chapter: undefined });\n    };\n  }, [\n    getIsPlaying,\n    pause,\n    play,\n    getProgress,\n    rewind,\n    setProgress,\n    seekTimeDelta,\n    ref,\n    onClick,\n  ]);\n}\n","import { useCallback, useEffect, useRef } from \"react\";\n\nexport const useAnimationFrame = (\n  frameRate: number,\n  callback: (deltaTime: number) => Promise<void> | void\n): void => {\n  const requestRef = useRef<number>();\n  const timeoutRef = useRef<number>();\n  const previousTimeRef = useRef<number>(Date.now());\n  const frameInterval = 1000 / frameRate;\n\n  const animate = useCallback(\n    async (time: number) => {\n      const deltaTime = time - previousTimeRef.current;\n      await new Promise((resolve) => resolve(callback(deltaTime)));\n\n      previousTimeRef.current = time;\n\n      timeoutRef.current = (setTimeout(() => {\n        requestRef.current = requestAnimationFrame(animate);\n      }, frameInterval) as unknown) as number;\n    },\n    [callback, frameInterval]\n  );\n\n  useEffect(() => {\n    timeoutRef.current = (setTimeout(() => {\n      requestRef.current = requestAnimationFrame(animate);\n    }, frameInterval) as unknown) as number;\n    return () => {\n      requestRef.current && cancelAnimationFrame(requestRef.current);\n      timeoutRef.current && clearTimeout(timeoutRef.current);\n    };\n  }, [animate, frameInterval]);\n};\n","export default __webpack_public_path__ + \"static/media/p2.2bd44c1d.mp4\";","import * as facemesh from \"@tensorflow-models/face-landmarks-detection\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport { Box } from \"grommet\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { Canvas, useThree } from \"react-three-fiber\";\nimport { BufferAttribute, BufferGeometry, Mesh } from \"three\";\nimport useResizeObserver from \"use-resize-observer\";\nimport { useChapter } from \"../../hooks/useChapter\";\nimport { useStore } from \"../../store/store\";\nimport videoSrc from \"./../../p2.mp4\";\nimport { useAsyncMemo } from \"./chapter2/useAsyncMemo\";\nimport { useAnimationFrame } from \"./chapter3/useAnimationFrame\";\n\nfunction Dots(props: { geometry: React.Ref<React.ReactNode> | undefined }) {\n  const { size } = useThree();\n  return (\n    <>\n      <points\n        scale={[size.width, size.height, 1]}\n        position={[-size.width / 2, size.height / 2, -5]}\n        frustumCulled={false}\n      >\n        <bufferGeometry ref={props.geometry}></bufferGeometry>\n        <pointsMaterial color=\"red\" size={10} />\n      </points>\n    </>\n  );\n}\n\nfunction Rect(props: { rectRef: React.Ref<React.ReactNode> | undefined }) {\n  const { size } = useThree();\n\n  return (\n    <group\n      position={[-size.width / 2, size.height / 2, -6]}\n      scale={[size.width, size.height, 1]}\n    >\n      <mesh ref={props.rectRef} frustumCulled={false}>\n        <planeBufferGeometry />\n        <meshNormalMaterial color={\"red\"} transparent opacity={0.1} />\n      </mesh>\n    </group>\n  );\n}\n\nexport default function Chapter2() {\n  const ref = useRef<HTMLVideoElement>(null);\n  const rectRef = useRef<Mesh>();\n  const webcamRef = useRef<HTMLVideoElement>(null);\n  const geometry = useRef<BufferGeometry>(null);\n  const [[canvasWidth, canvasHeight], setCanvasSize] = useState([\n    window.innerWidth,\n    window.innerHeight,\n  ]);\n  useChapter(ref, true);\n\n  const webcamStream = useStore((state) => state.webcamStream);\n  const model = useAsyncMemo(\n    async () =>\n      await facemesh.load(facemesh.SupportedPackages.mediapipeFacemesh, {\n        shouldLoadIrisModel: false,\n        maxFaces: 1,\n      }),\n    [],\n    undefined\n  );\n  const { width: videoDivWidth, height: videoDivHeight } = useResizeObserver({\n    ref: ref,\n  });\n\n  useEffect(() => {\n    if (!webcamStream || !webcamRef.current) return;\n    const video = webcamRef.current;\n    video.srcObject = webcamStream;\n    video.play();\n\n    const track = webcamStream.getVideoTracks()[0]!;\n    video.width = track.getSettings().width!;\n    video.height = track.getSettings().height!;\n  }, [webcamStream]);\n\n  useEffect(() => {\n    if (\n      !webcamStream ||\n      !webcamRef.current ||\n      !videoDivWidth ||\n      !videoDivHeight\n    )\n      return;\n    const video = webcamRef.current;\n    const videoAspect = video.width / video.height;\n    const width = Math.min(videoDivWidth, videoDivHeight * videoAspect);\n    const height = Math.min(videoDivWidth / videoAspect, videoDivHeight);\n    setCanvasSize([width, height]);\n  }, [videoDivHeight, videoDivWidth, webcamStream]);\n\n  useAnimationFrame(60, async () => {\n    if (!webcamStream || !webcamRef.current || !model || !rectRef.current)\n      return;\n    const video = webcamRef.current;\n\n    if (video.readyState < HTMLMediaElement.HAVE_METADATA) return;\n\n    const predictions = await model.estimateFaces({\n      input: webcamRef.current,\n      returnTensors: false,\n      flipHorizontal: false,\n      predictIrises: false,\n    });\n\n    if (predictions?.length <= 0) return;\n\n    const landmarks = predictions[0]!.scaledMesh as [number, number, number][];\n    const topLeft = predictions[0]!.boundingBox.topLeft as [number, number];\n    const bottomRight = predictions[0]!.boundingBox.bottomRight! as [\n      number,\n      number\n    ];\n\n    const positions3d = landmarks.flatMap(([x, y], index) => [\n      x / video.videoWidth,\n      -y / video.videoHeight,\n      0.0,\n    ]);\n\n    geometry.current?.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(positions3d), 3)\n    );\n\n    const centerX = (topLeft[0] + bottomRight[0]) / 2;\n    const centerY = (topLeft[1] + bottomRight[1]) / 2;\n\n    const width = bottomRight[0] - topLeft[0];\n    const height = bottomRight[1] - topLeft[1];\n\n    rectRef.current?.scale.setX(width / video.videoWidth);\n    rectRef.current?.scale.setY(height / video.videoHeight);\n    rectRef.current?.position.setX(centerX / video.videoWidth);\n    rectRef.current?.position.setY(-centerY / video.videoHeight);\n  });\n\n  return (\n    <Box\n      style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}\n      align=\"center\"\n    >\n      <video\n        style={{\n          position: \"absolute\",\n          top: 0,\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n        ref={webcamRef}\n        hidden\n      ></video>\n      <Canvas\n        style={{\n          position: \"absolute\",\n          width: canvasWidth + \"px\",\n          height: canvasHeight + \"px\",\n          top: \"50%\",\n          transform: \"translateY(-50%)\",\n        }}\n        orthographic={true}\n      >\n        <Dots geometry={geometry}></Dots>\n        <Rect rectRef={rectRef}></Rect>\n      </Canvas>\n      <video\n        ref={ref}\n        style={{\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n        width=\"100%\"\n        height=\"100%\"\n        src={videoSrc}\n      ></video>\n    </Box>\n  );\n}\n\n// Squares and 6 dpts\n// function Chapter2BlazeFace() {\n//   const ref = useRef<HTMLVideoElement>(null);\n//   const rectRef = useRef<Mesh>();\n//   const webcamRef = useRef<HTMLVideoElement>(null);\n//   const geometry = useRef<BufferGeometry>(null);\n//   const [canvasAspectRatio, setCanvasAspectRatio] = useState(\n//     window.innerWidth / window.innerHeight\n//   );\n//   useChapter(ref, true);\n\n//   const webcamStream = useStore((state) => state.webcamStream);\n\n//   const model = useRef<blazeface.BlazeFaceModel>();\n\n//   useEffect(() => {\n//     if (!webcamStream || !webcamRef.current) return;\n//     const video = webcamRef.current;\n//     video.srcObject = webcamStream;\n\n//     const track = webcamStream.getVideoTracks()[0]!;\n//     video.width = track.getSettings().width!;\n//     video.height = track.getSettings().height!;\n\n//     setCanvasAspectRatio(video.width / video.height);\n\n//     video.play();\n\n//     const effect = async () => {\n//       await new Promise((resolve) => {\n//         video.onloadedmetadata = () => {\n//           resolve(video);\n//         };\n//       });\n\n//       model.current = await blazeface.load({\n//         maxFaces: 1,\n//       });\n//     };\n\n//     effect();\n//   }, [model, webcamStream]);\n\n//   useAnimationFrame(15, async () => {\n//     if (\n//       !webcamStream ||\n//       !webcamRef.current ||\n//       !model.current ||\n//       !rectRef.current\n//     )\n//       return;\n//     const video = webcamRef.current;\n\n//     const predictions = await model.current.estimateFaces(\n//       webcamRef.current,\n//       false\n//     );\n\n//     if (predictions?.length <= 0) return;\n\n//     const landmarks = predictions[0]!.landmarks! as [number, number][];\n//     const topLeft = predictions[0]!.topLeft! as [number, number];\n//     const bottomRight = predictions[0]!.bottomRight! as [number, number];\n\n//     const positions3d = landmarks.flatMap(([x, y], index) => [\n//       x / video.videoWidth,\n//       -y / video.videoHeight,\n//       0.0,\n//     ]);\n\n//     geometry.current?.setAttribute(\n//       \"position\",\n//       new BufferAttribute(new Float32Array(positions3d), 3)\n//     );\n\n//     const centerX = (topLeft[0] + bottomRight[0]) / 2;\n//     const centerY = (topLeft[1] + bottomRight[1]) / 2;\n\n//     const width = bottomRight[0] - topLeft[0];\n//     const height = bottomRight[1] - topLeft[1];\n\n//     rectRef.current.scale.setX(width / video.videoWidth);\n//     rectRef.current.scale.setY(height / video.videoHeight);\n//     rectRef.current.position.setX(centerX / video.videoWidth);\n//     rectRef.current.position.setY(-centerY / video.videoHeight);\n//   });\n\n//   return (\n//     <Box\n//       style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}\n//       align=\"center\"\n//     >\n//       <video\n//         style={{\n//           position: \"absolute\",\n//           top: 0,\n//           boxSizing: \"border-box\",\n//           outline: \"none\",\n//           width: \"100%\",\n//           height: \"100%\",\n//         }}\n//         ref={webcamRef}\n//         // hidden\n//       ></video>\n//       <Canvas\n//         style={{\n//           position: \"absolute\",\n//           width: Math.min(1 / canvasAspectRatio, 1) * 100 + \"%\",\n//           height: \"100%\",\n//         }}\n//         orthographic={true}\n//       >\n//         <Dots geometry={geometry}></Dots>\n//         <Rect rectRef={rectRef}></Rect>\n//       </Canvas>\n//       <video\n//         ref={ref}\n//         style={{\n//           boxSizing: \"border-box\",\n//           outline: \"none\",\n//           width: \"100%\",\n//           height: \"100%\",\n//         }}\n//         width=\"100%\"\n//         height=\"100%\"\n//         src={videoSrc}\n//       ></video>\n//     </Box>\n//   );\n// }\n\n// function Chapter2CLMTracker() {\n//   const ref = useRef<HTMLVideoElement>(null);\n//   const webcamRef = useRef<HTMLVideoElement>(null);\n//   const geometry = useRef<BufferGeometry>(null);\n//   const [canvasAspectRatio, setCanvasAspectRatio] = useState(\n//     window.innerWidth / window.innerHeight\n//   );\n//   useChapter(ref, true);\n\n//   const webcamStream = useStore((state) => state.webcamStream);\n\n//   const tracker = useRef<clm.tracker>();\n\n//   useEffect(() => {\n//     if (!webcamStream || !webcamRef.current) return;\n//     const video = webcamRef.current;\n//     video.srcObject = webcamStream;\n\n//     const track = webcamStream.getVideoTracks()[0]!;\n//     video.width = track.getSettings().width!;\n//     video.height = track.getSettings().height!;\n\n//     setCanvasAspectRatio(video.width / video.height);\n\n//     video.play();\n//     tracker.current = new clm.tracker();\n//     tracker.current.init();\n//     tracker.current.start(video);\n//   }, [tracker, webcamStream]);\n\n//   useAnimationFrame(15, () => {\n//     const positions = tracker.current?.getCurrentPosition() || undefined;\n\n//     console.log(tracker.current?.getConvergence());\n//     if (!webcamStream || !webcamRef.current) return;\n//     const video = webcamRef.current;\n\n//     if (!positions) return;\n//     if (!geometry.current) return;\n\n//     const positions3d = positions.flatMap(([x, y], index) => [\n//       x / video.videoWidth,\n//       -y / video.videoHeight,\n//       0.0,\n//     ]);\n\n//     geometry.current?.setAttribute(\n//       \"position\",\n//       new BufferAttribute(new Float32Array(positions3d), 3)\n//     );\n//   });\n\n//   return (\n//     <Box\n//       style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}\n//       align=\"center\"\n//     >\n//       <video\n//         style={{\n//           position: \"absolute\",\n//           top: 0,\n//           boxSizing: \"border-box\",\n//           outline: \"none\",\n//           width: \"100%\",\n//           height: \"100%\",\n//         }}\n//         ref={webcamRef}\n//         hidden\n//       ></video>\n//       <Canvas\n//         style={{\n//           position: \"absolute\",\n//           width: Math.min(1 / canvasAspectRatio, 1) * 100 + \"%\",\n//           height: \"100%\",\n//         }}\n//         orthographic={true}\n//       >\n//         <Dots geometry={geometry}></Dots>\n//       </Canvas>\n//       <video\n//         ref={ref}\n//         style={{\n//           boxSizing: \"border-box\",\n//           outline: \"none\",\n//           width: \"100%\",\n//           height: \"100%\",\n//         }}\n//         width=\"100%\"\n//         height=\"100%\"\n//         src={videoSrc}\n//       ></video>\n//     </Box>\n//   );\n// }\n","import { DependencyList, useEffect, useState } from \"react\";\n\nexport function useAsyncMemo<T extends any | undefined>(\n  factory: () => Promise<T> | undefined | null,\n  deps: DependencyList,\n  initial: T\n): T {\n  const [val, setVal] = useState<T>(initial);\n  useEffect(() => {\n    let cancel = false;\n    const promise = factory();\n    if (promise === undefined || promise === null) return;\n    promise.then((val) => {\n      if (!cancel) {\n        setVal(val);\n      }\n    });\n    return () => {\n      cancel = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  return val;\n}\n"],"sourceRoot":""}