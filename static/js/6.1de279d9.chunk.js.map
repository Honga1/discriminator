{"version":3,"sources":["store/PredictionsStore.ts","store/makeObservable.ts","hooks/usePredictions.tsx","chapters/chapter2/part1/WorldOffset.tsx","chapters/chapter4/Cover4.tsx"],"names":["PredictionsStore","getMouthPosition","scaledMesh","topHead","bottomHead","topLip","bottomLip","headSize","Vector3","distanceTo","mouthGap","clamp","areEyesOpen","topLeftEyelid","bottomLeftEyelid","leftEyeLeftCrease","leftEyeRightCrease","topRightEyelid","bottomRightEyelid","rightEyeLeftCrease","rightEyeRightCrease","leftEyeWidth","rightEyeWidth","leftEyeOpenGap","rightEyeOpenGap","empiricalLeftEyeOpenAmount","empiricalRightEyeOpenAmount","getScaledMesh","prediction","video","map","x","y","z","videoWidth","videoHeight","getMesh","aspect","mesh","getBoundingBox","topLeft","boundingBox","bottomRight","getOrthoVectors","forward","a","b","c","side1","subVectors","side2","crossVectors","normalize","getForwardVector","left","a2","b2","c2","side3","side4","getLeftVector","up","sub","getUpVector","predictions","target","listeners","Set","value","unsubscribe","listenerFunc","delete","get","set","newValue","forEach","listener","subscribe","onChanged","add","makeObservable","modelPromise","webcam","isUpdating","update","size","undefined","console","log","facemesh","mediapipeFacemesh","shouldLoadIrisModel","maxFaces","readyState","HTMLMediaElement","HAVE_METADATA","requestAnimationFrame","estimateFaces","input","returnTensors","flipHorizontal","predictIrises","rawPrediction","orthoVectors","mouthOpened","eyesOpened","usePredictions","useRef","useStore","state","webcamHTMLElement","useEffect","incoming","current","WorldOffset","scale","children","targetAspect","viewport","useThree","height","position","Cover4","webcamAspect","style","width","orthographic","WebcamPlane","ref","Math","min","videoTexture","useMemo","VideoTexture","points","useFrame","xMin","yMax","xMax","yMin","material","uniforms","w","useMouthPosition","fourPoints","useLeftEyePosition","useRightEyePosition","useLeftIrisPosition","useRightIrisPosition","object","maskMaterial","attach","uniforms-map-value","uniforms-mouth-value","Vector4","uniforms-leftEye-value","uniforms-rightEye-value","uniforms-rightIris-value","uniforms-leftIris-value","Infinity","index","max","ShaderMaterial","fragmentShader","vertexShader","transparent","mouth","leftEye","rightEye","leftIris","rightIris"],"mappings":"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","file":"static/js/6.1de279d9.chunk.js","sourcesContent":["import * as facemesh from \"@tensorflow-models/face-landmarks-detection\";\nimport {\n  AnnotatedPrediction,\n  MediaPipeFaceMesh,\n} from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport { clamp } from \"src/libs/math\";\nimport { V2 } from \"src/libs/v2\";\nimport { V3 } from \"src/libs/v3\";\nimport { Vector3 } from \"three\";\nimport { makeObservable } from \"./makeObservable\";\n\nexport interface Predictions {\n  scaledMesh: V3[];\n  mesh: V3[];\n  boundingBox: {\n    topLeft: V2;\n    bottomRight: V2;\n  };\n\n  orthoVectors: {\n    up: Vector3;\n    left: Vector3;\n    forward: Vector3;\n  };\n\n  mouthOpened: number;\n  eyesOpened: boolean;\n}\n\nexport class PredictionsStore {\n  private static predictions = makeObservable<Predictions[]>([]);\n  private static modelPromise: undefined | Promise<MediaPipeFaceMesh>;\n  private static webcam: undefined | HTMLVideoElement;\n  private static isUpdating = false;\n\n  static update = async () => {\n    PredictionsStore.isUpdating = false;\n    if (PredictionsStore.predictions.listeners.size === 0) return;\n    if (PredictionsStore.modelPromise === undefined) {\n      console.log(\"Loading model\");\n      PredictionsStore.modelPromise = facemesh.load(\n        facemesh.SupportedPackages.mediapipeFacemesh,\n        {\n          shouldLoadIrisModel: true,\n          maxFaces: 1,\n        }\n      );\n      console.log(\"Loaded model\");\n    }\n    if (PredictionsStore.webcam === undefined) return;\n    const webcam = PredictionsStore.webcam;\n\n    PredictionsStore.isUpdating = true;\n\n    if (webcam.readyState < HTMLMediaElement.HAVE_METADATA)\n      return requestAnimationFrame(PredictionsStore.update);\n\n    const rawPrediction = await (\n      await PredictionsStore.modelPromise\n    ).estimateFaces({\n      input: webcam,\n      returnTensors: false,\n      flipHorizontal: false,\n      predictIrises: true,\n    });\n\n    const predictions = rawPrediction.map((prediction) => {\n      const scaledMesh = getScaledMesh(prediction, webcam);\n      const mesh = getMesh(prediction, webcam);\n      const boundingBox = getBoundingBox(prediction, webcam);\n      const orthoVectors = getOrthoVectors(mesh);\n      const mouthOpened = getMouthPosition(mesh);\n      const eyesOpened = areEyesOpen(mesh);\n\n      return {\n        scaledMesh,\n        boundingBox,\n        orthoVectors,\n        mouthOpened,\n        mesh,\n        eyesOpened,\n      };\n    });\n\n    PredictionsStore.predictions.set(predictions);\n\n    requestAnimationFrame(PredictionsStore.update);\n  };\n\n  static subscribe = (\n    webcam: HTMLVideoElement,\n    listener: (value: Predictions[]) => void\n  ) => {\n    const unsubscribe = PredictionsStore.predictions.subscribe(listener);\n    console.log(\n      `Added subscriber, have ${PredictionsStore.predictions.listeners.size} listeners`\n    );\n    PredictionsStore.webcam = webcam;\n    if (!PredictionsStore.isUpdating) PredictionsStore.update();\n    return () => {\n      console.log(\"Removing subscriber\");\n      return unsubscribe();\n    };\n  };\n\n  static get = PredictionsStore.predictions.get;\n}\n\nfunction getMouthPosition(scaledMesh: V3[]) {\n  const topHead = scaledMesh[10]!;\n  const bottomHead = scaledMesh[152]!;\n\n  const topLip = scaledMesh[12]!;\n  const bottomLip = scaledMesh[15]!;\n\n  const headSize = new Vector3(...topHead).distanceTo(\n    new Vector3(...bottomHead)\n  );\n  const mouthGap = new Vector3(...topLip).distanceTo(new Vector3(...bottomLip));\n\n  const empiricalMouthOpenAmount = clamp(\n    (mouthGap / headSize - 0.03) / 0.15,\n    0,\n    1\n  );\n  return empiricalMouthOpenAmount;\n}\n\nfunction areEyesOpen(scaledMesh: V3[]) {\n  const topLeftEyelid = scaledMesh[159]!;\n  const bottomLeftEyelid = scaledMesh[145]!;\n\n  const leftEyeLeftCrease = scaledMesh[33]!;\n  const leftEyeRightCrease = scaledMesh[133]!;\n\n  const topRightEyelid = scaledMesh[386]!;\n  const bottomRightEyelid = scaledMesh[374]!;\n\n  const rightEyeLeftCrease = scaledMesh[362]!;\n  const rightEyeRightCrease = scaledMesh[263]!;\n\n  const leftEyeWidth = new Vector3(...leftEyeLeftCrease).distanceTo(\n    new Vector3(...leftEyeRightCrease)\n  );\n\n  const rightEyeWidth = new Vector3(...rightEyeLeftCrease).distanceTo(\n    new Vector3(...rightEyeRightCrease)\n  );\n\n  const leftEyeOpenGap = new Vector3(...bottomLeftEyelid).distanceTo(\n    new Vector3(...topLeftEyelid)\n  );\n  const rightEyeOpenGap = new Vector3(...bottomRightEyelid).distanceTo(\n    new Vector3(...topRightEyelid)\n  );\n\n  const empiricalLeftEyeOpenAmount = clamp(\n    leftEyeOpenGap / (leftEyeWidth * 2),\n    0,\n    1\n  );\n  const empiricalRightEyeOpenAmount = clamp(\n    rightEyeOpenGap / (rightEyeWidth * 2),\n    0,\n    1\n  );\n\n  return (\n    empiricalLeftEyeOpenAmount > 0.11 && empiricalRightEyeOpenAmount > 0.11\n  );\n}\n\nfunction getScaledMesh(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  return (prediction.scaledMesh as V3[]).map(([x, y, z]) => {\n    return [\n      x / video.videoWidth,\n      -y / video.videoHeight,\n      -z / video.videoWidth,\n    ] as V3;\n  });\n}\n\nfunction getMesh(prediction: AnnotatedPrediction, video: HTMLVideoElement) {\n  const aspect = video.videoWidth / video.videoHeight;\n  if (video.videoHeight > video.videoWidth) {\n    return (prediction.mesh as V3[]).map(([x, y, z]) => {\n      return [x / 192, (-y / 192) * aspect, -z / 192] as V3;\n    });\n  } else {\n    return (prediction.mesh as V3[]).map(([x, y, z]) => {\n      const correctedX = (x - 192 / 2) / 192 / aspect + 0.5;\n      return [correctedX, -y / 192, -z / 192] as V3;\n    });\n  }\n}\n\nfunction getBoundingBox(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  const topLeft = [\n    (prediction.boundingBox.topLeft as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.topLeft as V2)[1] / video.videoHeight,\n  ] as V2;\n  const bottomRight = [\n    (prediction.boundingBox.bottomRight as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.bottomRight as V2)[1] / video.videoHeight,\n  ] as V2;\n  const boundingBox = {\n    topLeft: topLeft,\n    bottomRight: bottomRight,\n  };\n  return boundingBox;\n}\n\nfunction getOrthoVectors(mesh: V3[]) {\n  const forward = getForwardVector(mesh);\n  const left = getLeftVector(mesh);\n  const up = getUpVector(mesh);\n  return { up, forward, left };\n}\n\nfunction getUpVector(mesh: V3[]) {\n  return new Vector3(...mesh[199]!).sub(new Vector3(...mesh[9]!)).normalize();\n}\n\nfunction getLeftVector(mesh: V3[]) {\n  const a2 = new Vector3(...mesh[4]!);\n  const b2 = new Vector3(...mesh[10]!);\n  const c2 = new Vector3(...mesh[152]!);\n  const side3 = new Vector3().subVectors(a2, b2);\n  const side4 = new Vector3().subVectors(a2, c2);\n  const facingSidewaysFromHead = new Vector3()\n    .crossVectors(side3, side4)\n    .normalize();\n  return facingSidewaysFromHead;\n}\n\nfunction getForwardVector(mesh: V3[]) {\n  const a = new Vector3(mesh[151]![0]!, mesh[151]![1]!, mesh[151]![2]!);\n  const b = new Vector3(mesh[285]![0]!, mesh[285]![1]!, mesh[285]![2]!);\n  const c = new Vector3(mesh[55]![0]!, mesh[55]![1]!, mesh[55]![2]!);\n\n  const side1 = new Vector3().subVectors(a, b);\n  const side2 = new Vector3().subVectors(a, c);\n  const facingOutFromHead = new Vector3()\n    .crossVectors(side2, side1)\n    .normalize();\n  return facingOutFromHead;\n}\n","export function makeObservable<T>(target: T): Observable<T> {\n  const listeners = new Set<(value: T) => void>();\n\n  let value = target;\n\n  const get = () => value;\n\n  const set = (newValue: T) => {\n    if (value === newValue) return;\n    value = newValue;\n\n    listeners.forEach((listener) => listener(value));\n  };\n\n  const subscribe = (onChanged: (value: T) => void) => {\n    listeners.add(onChanged);\n    return () => unsubscribe(onChanged);\n  };\n\n  const unsubscribe = (listenerFunc: (value: T) => void) => {\n    listeners.delete(listenerFunc);\n  };\n\n  return {\n    get,\n    set,\n    subscribe,\n    listeners,\n  };\n}\ninterface Observable<T> {\n  get(): T;\n  set(value: T): void;\n  subscribe(listener: (value: T) => void): () => void;\n  readonly listeners: Set<(value: T) => void>;\n}\n","import { useEffect, useRef } from \"react\";\nimport { Predictions, PredictionsStore } from \"src/store/PredictionsStore\";\nimport { useStore } from \"src/store/store\";\n\nexport function usePredictions() {\n  const predictions = useRef<Predictions[]>([]);\n  const webcam = useStore((state) => state.webcamHTMLElement);\n\n  useEffect(() => {\n    return PredictionsStore.subscribe(webcam, (incoming) => {\n      predictions.current = incoming;\n    });\n  }, [webcam]);\n\n  return predictions;\n}\n","import React, { PropsWithChildren } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\nimport { V3 } from \"../../../libs/v3\";\n\n/**\n * Makes world scale 0-1, and position 0-1 for width and height\n */\nexport const WorldOffset = ({\n  children,\n  targetAspect,\n}: PropsWithChildren<{ targetAspect: number }>) => {\n  const { viewport } = useThree();\n\n  let scale: V3;\n  if (viewport.aspect < targetAspect) {\n    // Is taller than webcam aspect\n    scale = [viewport.height, viewport.height / targetAspect, 1];\n  } else {\n    // Is wider than webcam aspect\n    scale = [viewport.height * targetAspect, viewport.height, 1];\n  }\n  return (\n    <group scale={scale} position={[-scale[0] / 2, scale[1] / 2, 0]}>\n      {children}\n    </group>\n  );\n};\n","import { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport React, { useMemo, useRef } from \"react\";\nimport { usePredictions } from \"src/hooks/usePredictions\";\nimport { V3 } from \"src/libs/v3\";\nimport { Predictions } from \"src/store/PredictionsStore\";\nimport {\n  BufferGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector4,\n  VideoTexture,\n} from \"three\";\nimport { useStore } from \"../../store/store\";\nimport { WorldOffset } from \"../chapter2/part1/WorldOffset\";\n\nexport default function Cover4() {\n  const aspect = useStore((state) => state.webcamAspect);\n\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        width: \"100%\",\n        height: \"100%\",\n      }}\n    >\n      <Canvas orthographic>\n        <WebcamPlane />\n        <WorldOffset targetAspect={aspect}>\n          {/* <WireframeMask track=\"webcam\" /> */}\n        </WorldOffset>\n      </Canvas>\n    </div>\n  );\n}\n\nfunction WebcamPlane() {\n  const webcam = useStore((state) => state.webcamHTMLElement);\n  const aspect = useStore((state) => state.webcamAspect);\n  const viewport = useThree((state) => state.viewport);\n\n  const ref = useRef<Mesh<BufferGeometry, ShaderMaterial>>();\n  const width = Math.min(viewport.width, viewport.height * aspect);\n  const height = Math.min(viewport.width / aspect, viewport.height);\n\n  const videoTexture = useMemo(() => {\n    return new VideoTexture(webcam);\n  }, [webcam]);\n\n  const predictions = usePredictions();\n\n  useMouthPosition(predictions, ref);\n  useLeftEyePosition(predictions, ref);\n  useRightEyePosition(predictions, ref);\n  useLeftIrisPosition(predictions, ref);\n  useRightIrisPosition(predictions, ref);\n\n  return (\n    <group scale={[width, height, 1]}>\n      <mesh ref={ref}>\n        <planeBufferGeometry />\n        <primitive\n          object={maskMaterial}\n          attach=\"material\"\n          uniforms-map-value={videoTexture}\n          uniforms-mouth-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n        />\n      </mesh>\n    </group>\n  );\n}\n\nfunction useMouthPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [\n    61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 146, 91, 181, 84, 17, 314,\n    405, 321, 375, 291,\n  ];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"mouth\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"mouth\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"mouth\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"mouth\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useLeftEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [225, 228, 189, 128];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [445, 448, 413, 357];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\nfunction useLeftIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [473, 474, 475, 476, 477];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [468, 469, 470, 471, 472];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction getBoundingBox(points: number[], mesh: V3[]) {\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let yMin = Infinity;\n\n  points.forEach((index) => {\n    const [x, y] = mesh[index]!;\n    xMin = Math.min(xMin, x);\n    xMax = Math.max(xMax, x);\n    yMin = Math.min(yMin, y);\n    yMax = Math.max(yMax, y);\n  });\n  return { xMin, yMax, xMax, yMin };\n}\n\nconst vert = /* glsl */ `\nvarying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec3 transformed = vec3( position );\n  vUv = uv.xy;\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n`;\n\nconst frag = /* glsl */ `\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec4 mouth;\nuniform vec4 leftEye;\nuniform vec4 rightEye;\nuniform vec4 leftIris;\nuniform vec4 rightIris;\n\n\nstruct Result {\n  vec2 uv;\n  float mixDistance;\n};\n\nResult getSmile() {\n  vec2 topLeft = mouth.xy;\n  vec2 bottomRight = mouth.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.2, 0.4)), 0.0, 1.0);\n\n  vec2 center = (topLeft + bottomRight) / 2.0;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n\n  float y = vUv.y - pow(abs(distanceFromCenterLine.x) /3.0, 2.5) * (1.2 - (vUv.y - topLeft.y)/distance.y) * 5.0;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x * 0.5;\n\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\nResult getLeftEye() {\n  vec2 leftIrisCenter = (leftIris.xy + leftIris.zw)/2.0;\n  vec2 topLeft = leftEye.xy;\n  vec2 bottomRight = leftEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = leftIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nResult getRightEye() {\n  vec2 rightIrisCenter = (rightIris.xy + rightIris.zw)/2.0;\n\n  vec2 topLeft = rightEye.xy;\n  vec2 bottomRight = rightEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = rightIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nvoid main() {\n    Result smile = getSmile();\n    Result leftEyeKawaii = getLeftEye();\n    Result rightEyeKawaii = getRightEye();\n    vec2 uv = mix(vUv, smile.uv, smile.mixDistance);\n    uv = mix(uv, leftEyeKawaii.uv, leftEyeKawaii.mixDistance);\n    uv = mix(uv, rightEyeKawaii.uv, rightEyeKawaii.mixDistance);\n    vec4 texelColor = texture2D( map, uv );\n    gl_FragColor = vec4(texelColor.rgb, 1.0);\n}\n`;\n\nconst maskMaterial = new ShaderMaterial({\n  fragmentShader: frag,\n  vertexShader: vert,\n  transparent: true,\n  uniforms: {\n    map: { value: undefined },\n    mouth: { value: undefined },\n    leftEye: { value: undefined },\n    rightEye: { value: undefined },\n    leftIris: { value: undefined },\n    rightIris: { value: undefined },\n  },\n});\n"],"sourceRoot":""}