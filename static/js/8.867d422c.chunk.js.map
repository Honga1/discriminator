{"version":3,"sources":["hooks/usePredictions.tsx","hooks/useHasFirstPrediction.tsx","chapters/chapter4/Cover4.tsx"],"names":["usePredictions","predictions","useRef","webcam","useStore","state","webcamHTMLElement","useEffect","PredictionsStore","subscribe","incoming","current","useHasFirstPrediction","useState","hasFirstFace","get","hasFirstPrediction","setHasFirstPrediction","Cover4","store","setState","isCameraEnabled","timeout1","setTimeout","timeout2","clearTimeout","useSpring","amount","config","duration","style","position","width","height","orthographic","WebcamPlane","padding","top","boxSizing","textAlign","color","size","textShadow","aspect","webcamAspect","viewport","useThree","ref","Math","min","videoTexture","useMemo","VideoTexture","points","useFrame","prediction","mesh","scaledMesh","getBoundingBox","xMin","yMax","xMax","yMin","undefined","material","uniforms","value","x","y","z","w","useMouthPosition","fourPoints","useLeftEyePosition","useRightEyePosition","useLeftIrisPosition","useRightIrisPosition","scale","object","maskMaterial","attach","uniforms-map-value","uniforms-mouth-value","Vector4","uniforms-leftEye-value","uniforms-rightEye-value","uniforms-rightIris-value","uniforms-leftIris-value","uniforms-amount-value","Infinity","forEach","index","max","ShaderMaterial","fragmentShader","vertexShader","transparent","map","mouth","leftEye","rightEye","leftIris","rightIris"],"mappings":"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","file":"static/js/8.867d422c.chunk.js","sourcesContent":["import { useEffect, useRef } from \"react\";\nimport { Predictions, PredictionsStore } from \"src/store/PredictionsStore\";\nimport { useStore } from \"src/store/store\";\n\nexport function usePredictions() {\n  const predictions = useRef<Predictions[]>([]);\n  const webcam = useStore((state) => state.webcamHTMLElement);\n\n  useEffect(() => {\n    return PredictionsStore.subscribe(webcam, (incoming) => {\n      predictions.current = incoming;\n    });\n  }, [webcam]);\n\n  return predictions;\n}\n","import { useEffect, useState } from \"react\";\nimport { PredictionsStore } from \"src/store/PredictionsStore\";\nimport { usePredictions } from \"./usePredictions\";\n\nexport const useHasFirstPrediction = () => {\n  usePredictions();\n  const [hasFirstPrediction, setHasFirstPrediction] = useState(\n    PredictionsStore.hasFirstFace.get()\n  );\n\n  useEffect(() => {\n    return PredictionsStore.hasFirstFace.subscribe(() => {\n      setHasFirstPrediction(true);\n    });\n  });\n\n  return hasFirstPrediction;\n};\n","import { SpringValue, useSpring } from \"@react-spring/core\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport { Text } from \"grommet\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport { usePredictions } from \"src/hooks/usePredictions\";\nimport { V3 } from \"src/libs/v3\";\nimport { Predictions } from \"src/store/PredictionsStore\";\nimport { store, useStore } from \"src/store/store\";\nimport {\n  BufferGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector4,\n  VideoTexture,\n} from \"three\";\nimport { useHasFirstPrediction } from \"src/hooks/useHasFirstPrediction\";\n\nexport default function Cover4() {\n  useEffect(() => {\n    store.setState({ isCameraEnabled: true });\n  }, []);\n\n  const [state, setState] = useState(0);\n\n  const hasFirstPrediction = useHasFirstPrediction();\n\n  useEffect(() => {\n    setState(0);\n\n    if (hasFirstPrediction) {\n      const timeout1 = setTimeout(() => setState(1), 5000);\n      const timeout2 = setTimeout(() => setState(2), 10000);\n      return () => {\n        clearTimeout(timeout1);\n        clearTimeout(timeout2);\n      };\n    }\n  }, [hasFirstPrediction]);\n\n  const [{ amount }] = useSpring(\n    () => ({\n      amount: state === 1 || state === 2 ? 1 : 0,\n      config: { duration: 5000 },\n    }),\n    [state]\n  );\n\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        width: \"100%\",\n        height: \"100%\",\n      }}\n    >\n      <div style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}>\n        <Canvas orthographic>\n          <WebcamPlane amount={amount} />\n        </Canvas>\n        <div\n          style={{\n            position: \"absolute\",\n            width: \"100%\",\n            padding: \"58px\",\n            top: 0,\n            boxSizing: \"border-box\",\n            textAlign: \"center\",\n          }}\n        >\n          <Text\n            color=\"yellow\"\n            size=\"32px\"\n            style={{\n              textShadow: `0px 4px 4px rgba(0, 0, 0, 0.25)`,\n            }}\n          >\n            {state === 0 && `You don't look happy :(`}\n            {state === 1 && `Let's see what we can do to fix that.`}\n            {state === 2 && `There, much better!`}\n          </Text>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction WebcamPlane({ amount }: { amount: SpringValue<number> }) {\n  const webcam = useStore((state) => state.webcamHTMLElement);\n  const aspect = useStore((state) => state.webcamAspect);\n  const viewport = useThree((state) => state.viewport);\n\n  const ref = useRef<Mesh<BufferGeometry, ShaderMaterial>>();\n  const width = Math.min(viewport.width, viewport.height * aspect);\n  const height = Math.min(viewport.width / aspect, viewport.height);\n\n  const videoTexture = useMemo(() => {\n    return new VideoTexture(webcam);\n  }, [webcam]);\n\n  const predictions = usePredictions();\n\n  useMouthPosition(predictions, ref);\n  useLeftEyePosition(predictions, ref);\n  useRightEyePosition(predictions, ref);\n  useLeftIrisPosition(predictions, ref);\n  useRightIrisPosition(predictions, ref);\n\n  useFrame(() => {\n    if (ref.current) {\n      ref.current.material.uniforms[\"amount\"]!.value = amount.get();\n    }\n  });\n\n  return (\n    <group scale={[width, height, 1]}>\n      <mesh ref={ref}>\n        <planeBufferGeometry />\n        <primitive\n          object={maskMaterial}\n          attach=\"material\"\n          uniforms-map-value={videoTexture}\n          uniforms-mouth-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-amount-value={0}\n        />\n      </mesh>\n    </group>\n  );\n}\n\nfunction useMouthPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [\n    61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 146, 91, 181, 84, 17, 314,\n    405, 321, 375, 291,\n  ];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"mouth\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"mouth\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"mouth\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"mouth\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useLeftEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [225, 228, 189, 128];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [445, 448, 413, 357];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\nfunction useLeftIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [473, 474, 475, 476, 477];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [468, 469, 470, 471, 472];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction getBoundingBox(points: number[], mesh: V3[]) {\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let yMin = Infinity;\n\n  points.forEach((index) => {\n    const [x, y] = mesh[index]!;\n    xMin = Math.min(xMin, x);\n    xMax = Math.max(xMax, x);\n    yMin = Math.min(yMin, y);\n    yMax = Math.max(yMax, y);\n  });\n  return { xMin, yMax, xMax, yMin };\n}\n\nconst vert = /* glsl */ `\nvarying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec3 transformed = vec3( position );\n  vUv = uv.xy;\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n`;\n\nconst frag = /* glsl */ `\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec4 mouth;\nuniform vec4 leftEye;\nuniform vec4 rightEye;\nuniform vec4 leftIris;\nuniform vec4 rightIris;\nuniform float amount;\n\nvec4 desaturate(vec3 color, float factor)\n{\n\tvec3 lum = vec3(0.299, 0.587, 0.114);\n\tvec3 gray = vec3(dot(lum, color));\n\treturn vec4(mix(color, gray, factor), 1.0);\n}\n\nstruct Result {\n  vec2 uv;\n  float mixDistance;\n};\n\nResult getSmile() {\n  vec2 topLeft = mouth.xy;\n  vec2 bottomRight = mouth.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.2, 0.4)), 0.0, 1.0);\n\n  vec2 center = (topLeft + bottomRight) / 2.0;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n\n  float y = vUv.y - pow(abs(distanceFromCenterLine.x) /3.0, 2.5) * (1.2 - (vUv.y - topLeft.y)/distance.y) * 5.0;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x * 0.5;\n\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\nResult getLeftEye() {\n  vec2 leftIrisCenter = (leftIris.xy + leftIris.zw)/2.0;\n  vec2 topLeft = leftEye.xy;\n  vec2 bottomRight = leftEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = leftIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nResult getRightEye() {\n  vec2 rightIrisCenter = (rightIris.xy + rightIris.zw)/2.0;\n\n  vec2 topLeft = rightEye.xy;\n  vec2 bottomRight = rightEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = rightIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nvoid main() {\n    Result smile = getSmile();\n    Result leftEyeKawaii = getLeftEye();\n    Result rightEyeKawaii = getRightEye();\n    vec2 uv = mix(vUv, smile.uv, smile.mixDistance * amount);\n    uv = mix(uv, leftEyeKawaii.uv, leftEyeKawaii.mixDistance * amount);\n    uv = mix(uv, rightEyeKawaii.uv, rightEyeKawaii.mixDistance * amount);\n    vec4 texelColor = texture2D( map, uv );\n    gl_FragColor = desaturate(texelColor.rgb, 1.0 - amount);\n}\n`;\n\nconst maskMaterial = new ShaderMaterial({\n  fragmentShader: frag,\n  vertexShader: vert,\n  transparent: true,\n  uniforms: {\n    map: { value: undefined },\n    mouth: { value: undefined },\n    leftEye: { value: undefined },\n    rightEye: { value: undefined },\n    leftIris: { value: undefined },\n    rightIris: { value: undefined },\n    amount: { value: undefined },\n  },\n});\n"],"sourceRoot":""}