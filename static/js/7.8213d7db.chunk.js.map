{"version":3,"sources":["p2.mp4","pages/chapters/chapter2/three/BoundingRectangle.tsx","pages/chapters/chapter2/three/Dots.tsx","pages/chapters/chapter2/three/WorldOffset.tsx","pages/chapters/chapter2/three/vomit.gltf","pages/chapters/chapter2/three/RainbowVomit.tsx","pages/chapters/chapter2/three/Scene.tsx","pages/chapters/chapter2/useModel.tsx","pages/chapters/chapter2/useAsyncMemo.tsx","pages/chapters/chapter2/usePredictions.tsx","pages/chapters/chapter2/Chapter2.tsx","pages/chapters/chapter2/useWebcamAndCanvas.tsx"],"names":["BoundingRectangle","predictions","ref","useRef","useFrame","current","length","topLeft","boundingBox","bottomRight","centerX","centerY","width","height","scale","setX","setY","position","frustumCulled","color","transparent","opacity","Dots","positions3d","scaledMesh","flat","setAttribute","BufferAttribute","Float32Array","size","WorldOffset","children","viewport","useThree","RainbowVomit","aRObject","useGLTF","vomitModel","nodes","animations","materials","useAnimations","actions","mixer","names","clips","useEffect","action","Action","loop","LoopRepeat","play","Cube","material","MeshBasicMaterial","prediction","mesh","orthoVectors","up","forward","set","add","Vector3","worldPosition","getWorldPosition","copy","lookAt","clone","negate","visible","mouthOpened","rotation","Math","PI","object","Scene","fallback","useModel","factory","deps","initial","useState","val","setVal","cancel","promise","undefined","then","useAsyncMemo","a","console","log","facemesh","mediapipeFacemesh","shouldLoadIrisModel","maxFaces","model","getScaledMesh","video","map","x","y","z","videoWidth","videoHeight","getBoundingBox","getOrthoVectors","b","c","side1","subVectors","side2","crossVectors","normalize","getForwardVector","left","a2","b2","c2","side3","side4","getLeftVector","sub","getUpVector","Chapter2","useChapter","Box","style","align","WebcamOverlay","boxSizing","outline","src","videoSrc","webcamRef","webcamStream","useResizeObserver","videoDivWidth","videoDivHeight","window","innerWidth","innerHeight","canvasWidth","canvasHeight","setCanvasSize","srcObject","track","getVideoTracks","getSettings","videoAspect","min","useWebcamAndCanvas","useStore","state","useAnimationFrame","readyState","HTMLMediaElement","HAVE_METADATA","estimateFaces","input","returnTensors","flipHorizontal","predictIrises","pixelScalePredictions","topHead","bottomHead","topLip","bottomLip","headSize","distanceTo","mouthGap","clamp","usePredictions","top","transform","orthographic"],"mappings":"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","file":"static/js/7.8213d7db.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/p2.2bd44c1d.mp4\";","import React, { useRef } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { Mesh } from \"three\";\nimport { Predictions } from \"../usePredictions\";\nimport { V2 } from \"../V2\";\n\nexport function BoundingRectangle({\n  predictions,\n}: {\n  predictions: { current: Predictions[] };\n}) {\n  const ref = useRef<Mesh>();\n\n  useFrame(() => {\n    if (predictions.current.length <= 0) return;\n    if (!ref.current) return;\n\n    const topLeft = predictions.current[0]!.boundingBox.topLeft as V2;\n    const bottomRight = predictions.current[0]!.boundingBox.bottomRight! as V2;\n\n    const centerX = (topLeft[0] + bottomRight[0]) / 2;\n    const centerY = (topLeft[1] + bottomRight[1]) / 2;\n\n    const width = bottomRight[0] - topLeft[0];\n    const height = bottomRight[1] - topLeft[1];\n\n    ref.current.scale.setX(width);\n    ref.current.scale.setY(height);\n    ref.current.position.setX(centerX);\n    ref.current.position.setY(centerY);\n  });\n\n  return (\n    <mesh ref={ref} frustumCulled={false}>\n      <planeBufferGeometry />\n      <meshNormalMaterial color={\"red\"} transparent opacity={0.1} />\n    </mesh>\n  );\n}\n","import React, { useRef } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { BufferAttribute, BufferGeometry } from \"three\";\nimport { Predictions } from \"../usePredictions\";\nimport { V3 } from \"../V3\";\n\nexport function Dots({\n  predictions,\n}: {\n  predictions: { current: Predictions[] };\n}) {\n  const ref = useRef<BufferGeometry>();\n  useFrame(() => {\n    if (predictions.current.length <= 0) return;\n    const landmarks = predictions.current[0]!.scaledMesh as V3[];\n    const positions3d = landmarks.flat();\n    ref.current?.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(positions3d), 3)\n    );\n  });\n\n  return (\n    <points frustumCulled={false}>\n      <bufferGeometry ref={ref}></bufferGeometry>\n      <pointsMaterial color=\"#20BF00\" size={0.08} />\n    </points>\n  );\n}\n","import React, { PropsWithChildren } from \"react\";\nimport { useThree } from \"@react-three/fiber\";\n\n/**\n * Makes world scale 0-1, and position 0-1 for width and height\n */\nexport const WorldOffset = ({ children }: PropsWithChildren<{}>) => {\n  const { viewport } = useThree();\n\n  return (\n    <group\n      scale={[viewport.width, viewport.height, 1]}\n      position={[-viewport.width / 2, viewport.height / 2, 0]}\n    >\n      {children}\n    </group>\n  );\n};\n","export default __webpack_public_path__ + \"static/media/vomit.246b25a7.gltf\";","import { useAnimations, useFBX, useGLTF } from \"@react-three/drei\";\nimport { useFrame } from \"@react-three/fiber\";\nimport React, { useEffect, useRef } from \"react\";\nimport { LoopRepeat, Mesh, MeshBasicMaterial, Vector3 } from \"three\";\nimport { Predictions } from \"../usePredictions\";\nimport { V3 } from \"../V3\";\nimport vomitModel from \"./vomit.gltf\";\n\nexport const RainbowVomit = ({\n  predictions,\n}: {\n  predictions: { current: Predictions[] };\n}) => {\n  const aRObject = useRef<Mesh>();\n\n  const { nodes, materials, animations } = useGLTF(vomitModel);\n\n  const { ref, mixer, names, actions, clips } = useAnimations(animations);\n\n  useEffect(() => {\n    const action = actions.Action;\n    if (!action) return;\n    action.loop = LoopRepeat;\n    action.play();\n\n    if ((nodes?.Cube as Mesh | undefined)?.material) {\n      (nodes.Cube as Mesh).material = new MeshBasicMaterial({ color: \"red\" });\n    }\n  });\n\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    if (!aRObject.current) return;\n\n    const mesh = prediction.scaledMesh as V3[];\n    const { up, forward } = prediction.orthoVectors;\n\n    aRObject.current.position.set(...mesh[13]!).add(new Vector3(0, 0, 0));\n\n    const worldPosition = new Vector3();\n    aRObject.current.getWorldPosition(worldPosition);\n    aRObject.current.up.copy(up);\n    aRObject.current.lookAt(forward.clone().negate().add(worldPosition));\n\n    if (ref.current) {\n      ref.current.visible = prediction.mouthOpened > 0.5;\n    }\n  });\n\n  return (\n    <group ref={aRObject} frustumCulled={false} scale={[0.04, 0.1, 0.1]}>\n      <group ref={ref} rotation={[0, Math.PI / 2, 0]} position={[0, 0, 3]}>\n        <primitive object={nodes.Cube} />\n      </group>\n\n      <mesh position={[0, 0, -1.5]}>\n        <boxBufferGeometry></boxBufferGeometry>\n        <meshNormalMaterial\n          color=\"red\"\n          transparent\n          opacity={1}\n        ></meshNormalMaterial>\n      </mesh>\n    </group>\n  );\n};\n","import React, { Suspense } from \"react\";\nimport { ARObject } from \"./ARObject\";\nimport { BoundingRectangle } from \"./BoundingRectangle\";\nimport { Dots } from \"./Dots\";\nimport { Gizmo } from \"./Gizmo\";\nimport { Mask } from \"./Mask\";\nimport { Predictions } from \"../usePredictions\";\nimport { WorldOffset } from \"./WorldOffset\";\nimport { RainbowVomit } from \"./RainbowVomit\";\n\nexport const Scene = ({\n  predictions,\n}: {\n  predictions: { current: Predictions[] };\n}) => {\n  return (\n    <WorldOffset>\n      {/* <Gizmo predictions={predictions} gizmoHome={4} /> */}\n      <Dots predictions={predictions}></Dots>\n      <BoundingRectangle predictions={predictions}></BoundingRectangle>\n      {/* <Mask predictions={predictions}></Mask> */}\n      {/* <ARObject predictions={predictions} /> */}\n\n      <Suspense fallback={null}>\n        <RainbowVomit predictions={predictions}></RainbowVomit>\n      </Suspense>\n    </WorldOffset>\n  );\n};\n","import * as facemesh from \"@tensorflow-models/face-landmarks-detection\";\nimport { useAsyncMemo } from \"./useAsyncMemo\";\n\nexport function useModel() {\n  return useAsyncMemo(\n    async () => {\n      console.log(\"Loading model\");\n      const model = await facemesh.load(\n        facemesh.SupportedPackages.mediapipeFacemesh,\n        {\n          shouldLoadIrisModel: false,\n          maxFaces: 1,\n        }\n      );\n\n      console.log(\"Loaded model\");\n      return model;\n    },\n    [],\n    undefined\n  );\n}\n","import { DependencyList, useEffect, useState } from \"react\";\n\nexport function useAsyncMemo<T extends any | undefined>(\n  factory: () => Promise<T> | undefined | null,\n  deps: DependencyList,\n  initial: T\n): T {\n  const [val, setVal] = useState<T>(initial);\n  useEffect(() => {\n    let cancel = false;\n    const promise = factory();\n    if (promise === undefined || promise === null) return;\n    promise.then((val) => {\n      if (!cancel) {\n        setVal(val);\n      }\n    });\n    return () => {\n      cancel = true;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n  return val;\n}\n","import { AnnotatedPrediction } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport React, { useRef } from \"react\";\nimport { useAnimationFrame } from \"../chapter3/useAnimationFrame\";\nimport { useModel } from \"./useModel\";\nimport { V3 } from \"./V3\";\nimport { V2 } from \"./V2\";\nimport { Vector3 } from \"three\";\nimport { clamp } from \"../chapter3/Part1Screen2/yearsInShownOrder\";\n\nexport interface Predictions {\n  scaledMesh: V3[];\n  boundingBox: {\n    topLeft: V2;\n    bottomRight: V2;\n  };\n\n  orthoVectors: {\n    up: Vector3;\n    left: Vector3;\n    forward: Vector3;\n  };\n\n  mouthOpened: number;\n}\n\nexport function usePredictions(webcamRef: React.RefObject<HTMLVideoElement>) {\n  const predictions = useRef<Predictions[]>([]);\n  const model = useModel();\n\n  useAnimationFrame(25, async () => {\n    if (!webcamRef.current || !model) return;\n    const video = webcamRef.current;\n\n    if (video.readyState < HTMLMediaElement.HAVE_METADATA) return;\n\n    const pixelScalePredictions = await model.estimateFaces({\n      input: webcamRef.current,\n      returnTensors: false,\n      flipHorizontal: false,\n      predictIrises: false,\n    });\n\n    predictions.current = pixelScalePredictions.map((prediction) => {\n      const scaledMesh = getScaledMesh(prediction, video);\n      const boundingBox = getBoundingBox(prediction, video);\n      const orthoVectors = getOrthoVectors(scaledMesh);\n\n      const topHead = scaledMesh[10]!;\n      const bottomHead = scaledMesh[152]!;\n\n      const topLip = scaledMesh[12]!;\n      const bottomLip = scaledMesh[15]!;\n\n      const headSize = new Vector3(...topHead).distanceTo(\n        new Vector3(...bottomHead)\n      );\n      const mouthGap = new Vector3(...topLip).distanceTo(\n        new Vector3(...bottomLip)\n      );\n\n      const empiricalMouthOpenAmount = clamp(\n        (mouthGap / headSize - 0.03) / 0.15,\n        0,\n        1\n      );\n\n      return {\n        scaledMesh,\n        boundingBox,\n        orthoVectors,\n        mouthOpened: empiricalMouthOpenAmount,\n      };\n    });\n  });\n\n  return predictions;\n}\nfunction getScaledMesh(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  return (prediction.scaledMesh as V3[]).map(([x, y, z]) => {\n    return [\n      x / video.videoWidth,\n      -y / video.videoHeight,\n      z / video.videoWidth,\n    ] as V3;\n  });\n}\n\nfunction getBoundingBox(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  const topLeft = [\n    (prediction.boundingBox.topLeft as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.topLeft as V2)[1] / video.videoHeight,\n  ] as V2;\n  const bottomRight = [\n    (prediction.boundingBox.bottomRight as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.bottomRight as V2)[1] / video.videoHeight,\n  ] as V2;\n  const boundingBox = {\n    topLeft: topLeft,\n    bottomRight: bottomRight,\n  };\n  return boundingBox;\n}\n\nfunction getOrthoVectors(mesh: V3[]) {\n  const forward = getForwardVector(mesh);\n  const left = getLeftVector(mesh);\n  const up = getUpVector(mesh);\n  return { up, forward, left };\n}\n\nfunction getUpVector(mesh: V3[]) {\n  return new Vector3(...mesh[9]!).sub(new Vector3(...mesh[199]!)).normalize();\n}\n\nfunction getLeftVector(mesh: V3[]) {\n  const a2 = new Vector3(...mesh[4]!);\n  const b2 = new Vector3(...mesh[10]!);\n  const c2 = new Vector3(...mesh[152]!);\n  const side3 = new Vector3().subVectors(a2, b2);\n  const side4 = new Vector3().subVectors(a2, c2);\n  const facingSidewaysFromHead = new Vector3()\n    .crossVectors(side3, side4)\n    .normalize();\n  return facingSidewaysFromHead;\n}\n\nfunction getForwardVector(mesh: V3[]) {\n  const a = new Vector3(mesh[151]![0]!, mesh[151]![1]!, -mesh[151]![2]!);\n  const b = new Vector3(mesh[285]![0]!, mesh[285]![1]!, -mesh[285]![2]!);\n  const c = new Vector3(mesh[55]![0]!, mesh[55]![1]!, -mesh[55]![2]!);\n\n  const side1 = new Vector3().subVectors(a, b);\n  const side2 = new Vector3().subVectors(a, c);\n  const facingOutFromHead = new Vector3()\n    .crossVectors(side2, side1)\n    .normalize();\n  return facingOutFromHead;\n}\n","import \"@tensorflow/tfjs-backend-webgl\";\nimport { Box } from \"grommet\";\nimport React, { useRef } from \"react\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { useChapter } from \"../../../hooks/useChapter\";\nimport { useStore } from \"../../../store/store\";\nimport videoSrc from \"./../../../p2.mp4\";\nimport { Scene } from \"./three/Scene\";\nimport { usePredictions } from \"./usePredictions\";\nimport { useWebcamAndCanvas } from \"./useWebcamAndCanvas\";\n\nexport default function Chapter2() {\n  const ref = useRef<HTMLVideoElement>(null);\n\n  useChapter(ref, true);\n\n  return (\n    <Box\n      style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}\n      align=\"center\"\n    >\n      <WebcamOverlay />\n      <video\n        ref={ref}\n        style={{\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n        width=\"100%\"\n        height=\"100%\"\n        src={videoSrc}\n      ></video>\n    </Box>\n  );\n}\n\nfunction WebcamOverlay() {\n  const webcamRef = useRef<HTMLVideoElement>(null);\n\n  const webcamStream = useStore((state) => state.webcamStream);\n\n  const [canvasWidth, canvasHeight] = useWebcamAndCanvas(\n    webcamRef,\n    webcamStream\n  );\n  const predictions = usePredictions(webcamRef);\n\n  return (\n    <>\n      <video\n        style={{\n          position: \"absolute\",\n          top: 0,\n          boxSizing: \"border-box\",\n          outline: \"none\",\n          width: \"100%\",\n          height: \"100%\",\n        }}\n        ref={webcamRef}\n        // hidden\n      ></video>\n      <Canvas\n        style={{\n          position: \"absolute\",\n          width: canvasWidth + \"px\",\n          height: canvasHeight + \"px\",\n          top: \"50%\",\n          transform: \"translateY(-50%)\",\n        }}\n        orthographic={false}\n      >\n        <Scene predictions={predictions}></Scene>\n      </Canvas>\n    </>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport useResizeObserver from \"use-resize-observer\";\nimport { V2 } from \"./V2\";\n\nexport function useWebcamAndCanvas(\n  webcamRef: React.RefObject<HTMLVideoElement>,\n  webcamStream: MediaStream | undefined\n) {\n  const { width: videoDivWidth, height: videoDivHeight } = useResizeObserver({\n    ref: webcamRef,\n  });\n\n  const [[canvasWidth, canvasHeight], setCanvasSize] = useState([\n    window.innerWidth,\n    window.innerHeight,\n  ]);\n\n  useEffect(() => {\n    if (\n      !webcamRef.current ||\n      !videoDivWidth ||\n      !videoDivHeight ||\n      !webcamStream\n    )\n      return;\n    const video = webcamRef.current;\n\n    if (video.srcObject !== webcamStream) {\n      video.srcObject = webcamStream;\n      video.play();\n    }\n\n    const track = webcamStream.getVideoTracks()[0]!;\n    video.width = track.getSettings().width!;\n    video.height = track.getSettings().height!;\n\n    const videoAspect = video.width / video.height;\n    const width = Math.min(videoDivWidth, videoDivHeight * videoAspect);\n    const height = Math.min(videoDivWidth / videoAspect, videoDivHeight);\n    setCanvasSize([width, height]);\n  }, [videoDivHeight, videoDivWidth, webcamRef, webcamStream]);\n\n  return [canvasWidth, canvasHeight] as V2;\n}\n"],"sourceRoot":""}