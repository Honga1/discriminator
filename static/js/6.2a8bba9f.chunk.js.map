{"version":3,"sources":["hooks/usePredictions.tsx","store/makeObservable.ts","store/PredictionsStore.ts","hooks/useHasFirstPrediction.tsx","chapters/chapter4/Cover4.tsx"],"names":["usePredictions","predictions","useRef","webcam","useStore","state","webcamHTMLElement","useEffect","PredictionsStore","subscribe","incoming","current","makeObservable","target","listeners","Set","value","unsubscribe","listenerFunc","delete","get","set","newValue","forEach","listener","onChanged","add","getMouthPosition","scaledMesh","topHead","bottomHead","topLip","bottomLip","headSize","Vector3","distanceTo","mouthGap","clamp","areEyesOpen","topLeftEyelid","bottomLeftEyelid","leftEyeLeftCrease","leftEyeRightCrease","topRightEyelid","bottomRightEyelid","rightEyeLeftCrease","rightEyeRightCrease","leftEyeWidth","rightEyeWidth","leftEyeOpenGap","rightEyeOpenGap","empiricalLeftEyeOpenAmount","empiricalRightEyeOpenAmount","getScaledMesh","prediction","video","map","x","y","z","videoWidth","videoHeight","getMesh","aspect","mesh","getBoundingBox","topLeft","boundingBox","bottomRight","getOrthoVectors","forward","a","b","c","side1","subVectors","side2","crossVectors","normalize","getForwardVector","left","a2","b2","c2","side3","side4","getLeftVector","up","sub","getUpVector","modelPromise","isUpdating","hasFirstFace","update","size","undefined","console","log","facemesh","mediapipeFacemesh","shouldLoadIrisModel","maxFaces","readyState","HTMLMediaElement","HAVE_METADATA","requestAnimationFrame","estimateFaces","input","returnTensors","flipHorizontal","predictIrises","rawPrediction","orthoVectors","mouthOpened","eyesOpened","useHasFirstPrediction","useState","hasFirstPrediction","setHasFirstPrediction","Cover4","store","setState","isCameraEnabled","timeout1","setTimeout","timeout2","clearTimeout","useSpring","amount","config","duration","style","position","width","height","orthographic","WebcamPlane","padding","top","boxSizing","textAlign","color","textShadow","webcamAspect","viewport","useThree","ref","Math","min","videoTexture","useMemo","VideoTexture","points","useFrame","xMin","yMax","xMax","yMin","material","uniforms","w","useMouthPosition","fourPoints","useLeftEyePosition","useRightEyePosition","useLeftIrisPosition","useRightIrisPosition","scale","object","maskMaterial","attach","uniforms-map-value","uniforms-mouth-value","Vector4","uniforms-leftEye-value","uniforms-rightEye-value","uniforms-rightIris-value","uniforms-leftIris-value","uniforms-amount-value","Infinity","index","max","ShaderMaterial","fragmentShader","vertexShader","transparent","mouth","leftEye","rightEye","leftIris","rightIris"],"mappings":"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","file":"static/js/6.2a8bba9f.chunk.js","sourcesContent":["import { useEffect, useRef } from \"react\";\nimport { Predictions, PredictionsStore } from \"src/store/PredictionsStore\";\nimport { useStore } from \"src/store/store\";\n\nexport function usePredictions() {\n  const predictions = useRef<Predictions[]>([]);\n  const webcam = useStore((state) => state.webcamHTMLElement);\n\n  useEffect(() => {\n    return PredictionsStore.subscribe(webcam, (incoming) => {\n      predictions.current = incoming;\n    });\n  }, [webcam]);\n\n  return predictions;\n}\n","export function makeObservable<T>(target: T): Observable<T> {\n  const listeners = new Set<(value: T) => void>();\n\n  let value = target;\n\n  const get = () => value;\n\n  const set = (newValue: T) => {\n    if (value === newValue) return;\n    value = newValue;\n\n    listeners.forEach((listener) => listener(value));\n  };\n\n  const subscribe = (onChanged: (value: T) => void) => {\n    listeners.add(onChanged);\n    return () => unsubscribe(onChanged);\n  };\n\n  const unsubscribe = (listenerFunc: (value: T) => void) => {\n    listeners.delete(listenerFunc);\n  };\n\n  return {\n    get,\n    set,\n    subscribe,\n    listeners,\n  };\n}\ninterface Observable<T> {\n  get(): T;\n  set(value: T): void;\n  subscribe(listener: (value: T) => void): () => void;\n  readonly listeners: Set<(value: T) => void>;\n}\n","import * as facemesh from \"@tensorflow-models/face-landmarks-detection\";\nimport {\n  AnnotatedPrediction,\n  MediaPipeFaceMesh,\n} from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh\";\nimport \"@tensorflow/tfjs-backend-webgl\";\nimport { clamp } from \"src/libs/math\";\nimport { V2 } from \"src/libs/v2\";\nimport { V3 } from \"src/libs/v3\";\nimport { Vector3 } from \"three\";\nimport { makeObservable } from \"./makeObservable\";\n\nexport interface Predictions {\n  scaledMesh: V3[];\n  mesh: V3[];\n  boundingBox: {\n    topLeft: V2;\n    bottomRight: V2;\n  };\n\n  orthoVectors: {\n    up: Vector3;\n    left: Vector3;\n    forward: Vector3;\n  };\n\n  mouthOpened: number;\n  eyesOpened: boolean;\n}\n\nexport class PredictionsStore {\n  private static predictions = makeObservable<Predictions[]>([]);\n  private static modelPromise: undefined | Promise<MediaPipeFaceMesh>;\n  private static webcam: undefined | HTMLVideoElement;\n  private static isUpdating = false;\n  static hasFirstFace = makeObservable(false);\n\n  static update = async () => {\n    PredictionsStore.isUpdating = false;\n    if (PredictionsStore.predictions.listeners.size === 0) return;\n    if (PredictionsStore.modelPromise === undefined) {\n      console.log(\"Loading model\");\n      PredictionsStore.modelPromise = facemesh.load(\n        facemesh.SupportedPackages.mediapipeFacemesh,\n        {\n          shouldLoadIrisModel: true,\n          maxFaces: 1,\n        }\n      );\n      console.log(\"Loaded model\");\n    }\n    if (PredictionsStore.webcam === undefined) return;\n    const webcam = PredictionsStore.webcam;\n\n    PredictionsStore.isUpdating = true;\n\n    if (webcam.readyState < HTMLMediaElement.HAVE_METADATA)\n      return requestAnimationFrame(PredictionsStore.update);\n\n    const rawPrediction = await (\n      await PredictionsStore.modelPromise\n    ).estimateFaces({\n      input: webcam,\n      returnTensors: false,\n      flipHorizontal: false,\n      predictIrises: true,\n    });\n\n    PredictionsStore.hasFirstFace.set(true);\n\n    const predictions = rawPrediction.map((prediction) => {\n      const scaledMesh = getScaledMesh(prediction, webcam);\n      const mesh = getMesh(prediction, webcam);\n      const boundingBox = getBoundingBox(prediction, webcam);\n      const orthoVectors = getOrthoVectors(mesh);\n      const mouthOpened = getMouthPosition(mesh);\n      const eyesOpened = areEyesOpen(mesh);\n\n      return {\n        scaledMesh,\n        boundingBox,\n        orthoVectors,\n        mouthOpened,\n        mesh,\n        eyesOpened,\n      };\n    });\n\n    PredictionsStore.predictions.set(predictions);\n\n    requestAnimationFrame(PredictionsStore.update);\n  };\n\n  static subscribe = (\n    webcam: HTMLVideoElement,\n    listener: (value: Predictions[]) => void\n  ) => {\n    const unsubscribe = PredictionsStore.predictions.subscribe(listener);\n    console.log(\n      `Added subscriber, have ${PredictionsStore.predictions.listeners.size} listeners`\n    );\n    PredictionsStore.webcam = webcam;\n    if (!PredictionsStore.isUpdating) PredictionsStore.update();\n    return () => {\n      console.log(\"Removing subscriber\");\n      return unsubscribe();\n    };\n  };\n\n  static get = PredictionsStore.predictions.get;\n}\n\nfunction getMouthPosition(scaledMesh: V3[]) {\n  const topHead = scaledMesh[10]!;\n  const bottomHead = scaledMesh[152]!;\n\n  const topLip = scaledMesh[12]!;\n  const bottomLip = scaledMesh[15]!;\n\n  const headSize = new Vector3(...topHead).distanceTo(\n    new Vector3(...bottomHead)\n  );\n  const mouthGap = new Vector3(...topLip).distanceTo(new Vector3(...bottomLip));\n\n  const empiricalMouthOpenAmount = clamp(\n    (mouthGap / headSize - 0.03) / 0.15,\n    0,\n    1\n  );\n  return empiricalMouthOpenAmount;\n}\n\nfunction areEyesOpen(scaledMesh: V3[]) {\n  const topLeftEyelid = scaledMesh[159]!;\n  const bottomLeftEyelid = scaledMesh[145]!;\n\n  const leftEyeLeftCrease = scaledMesh[33]!;\n  const leftEyeRightCrease = scaledMesh[133]!;\n\n  const topRightEyelid = scaledMesh[386]!;\n  const bottomRightEyelid = scaledMesh[374]!;\n\n  const rightEyeLeftCrease = scaledMesh[362]!;\n  const rightEyeRightCrease = scaledMesh[263]!;\n\n  const leftEyeWidth = new Vector3(...leftEyeLeftCrease).distanceTo(\n    new Vector3(...leftEyeRightCrease)\n  );\n\n  const rightEyeWidth = new Vector3(...rightEyeLeftCrease).distanceTo(\n    new Vector3(...rightEyeRightCrease)\n  );\n\n  const leftEyeOpenGap = new Vector3(...bottomLeftEyelid).distanceTo(\n    new Vector3(...topLeftEyelid)\n  );\n  const rightEyeOpenGap = new Vector3(...bottomRightEyelid).distanceTo(\n    new Vector3(...topRightEyelid)\n  );\n\n  const empiricalLeftEyeOpenAmount = clamp(\n    leftEyeOpenGap / (leftEyeWidth * 2),\n    0,\n    1\n  );\n  const empiricalRightEyeOpenAmount = clamp(\n    rightEyeOpenGap / (rightEyeWidth * 2),\n    0,\n    1\n  );\n\n  return (\n    empiricalLeftEyeOpenAmount > 0.11 && empiricalRightEyeOpenAmount > 0.11\n  );\n}\n\nfunction getScaledMesh(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  return (prediction.scaledMesh as V3[]).map(([x, y, z]) => {\n    return [\n      x / video.videoWidth,\n      -y / video.videoHeight,\n      -z / video.videoWidth,\n    ] as V3;\n  });\n}\n\nfunction getMesh(prediction: AnnotatedPrediction, video: HTMLVideoElement) {\n  const aspect = video.videoWidth / video.videoHeight;\n  if (video.videoHeight > video.videoWidth) {\n    return (prediction.mesh as V3[]).map(([x, y, z]) => {\n      return [x / 192, (-y / 192) * aspect, -z / 192] as V3;\n    });\n  } else {\n    return (prediction.mesh as V3[]).map(([x, y, z]) => {\n      const correctedX = (x - 192 / 2) / 192 / aspect + 0.5;\n      return [correctedX, -y / 192, -z / 192] as V3;\n    });\n  }\n}\n\nfunction getBoundingBox(\n  prediction: AnnotatedPrediction,\n  video: HTMLVideoElement\n) {\n  const topLeft = [\n    (prediction.boundingBox.topLeft as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.topLeft as V2)[1] / video.videoHeight,\n  ] as V2;\n  const bottomRight = [\n    (prediction.boundingBox.bottomRight as V2)[0] / video.videoWidth,\n    -(prediction.boundingBox.bottomRight as V2)[1] / video.videoHeight,\n  ] as V2;\n  const boundingBox = {\n    topLeft: topLeft,\n    bottomRight: bottomRight,\n  };\n  return boundingBox;\n}\n\nfunction getOrthoVectors(mesh: V3[]) {\n  const forward = getForwardVector(mesh);\n  const left = getLeftVector(mesh);\n  const up = getUpVector(mesh);\n  return { up, forward, left };\n}\n\nfunction getUpVector(mesh: V3[]) {\n  return new Vector3(...mesh[199]!).sub(new Vector3(...mesh[9]!)).normalize();\n}\n\nfunction getLeftVector(mesh: V3[]) {\n  const a2 = new Vector3(...mesh[4]!);\n  const b2 = new Vector3(...mesh[10]!);\n  const c2 = new Vector3(...mesh[152]!);\n  const side3 = new Vector3().subVectors(a2, b2);\n  const side4 = new Vector3().subVectors(a2, c2);\n  const facingSidewaysFromHead = new Vector3()\n    .crossVectors(side3, side4)\n    .normalize();\n  return facingSidewaysFromHead;\n}\n\nfunction getForwardVector(mesh: V3[]) {\n  const a = new Vector3(mesh[151]![0]!, mesh[151]![1]!, mesh[151]![2]!);\n  const b = new Vector3(mesh[285]![0]!, mesh[285]![1]!, mesh[285]![2]!);\n  const c = new Vector3(mesh[55]![0]!, mesh[55]![1]!, mesh[55]![2]!);\n\n  const side1 = new Vector3().subVectors(a, b);\n  const side2 = new Vector3().subVectors(a, c);\n  const facingOutFromHead = new Vector3()\n    .crossVectors(side2, side1)\n    .normalize();\n  return facingOutFromHead;\n}\n","import { useEffect, useState } from \"react\";\nimport { PredictionsStore } from \"src/store/PredictionsStore\";\n\nexport const useHasFirstPrediction = () => {\n  const [hasFirstPrediction, setHasFirstPrediction] = useState(\n    PredictionsStore.hasFirstFace.get()\n  );\n\n  useEffect(() => {\n    return PredictionsStore.hasFirstFace.subscribe(() => {\n      setHasFirstPrediction(true);\n    });\n  });\n\n  return hasFirstPrediction;\n};\n","import { SpringValue, useSpring } from \"@react-spring/core\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport { Text } from \"grommet\";\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport { usePredictions } from \"src/hooks/usePredictions\";\nimport { V3 } from \"src/libs/v3\";\nimport { Predictions } from \"src/store/PredictionsStore\";\nimport { store, useStore } from \"src/store/store\";\nimport {\n  BufferGeometry,\n  Mesh,\n  ShaderMaterial,\n  Vector4,\n  VideoTexture,\n} from \"three\";\nimport { useHasFirstPrediction } from \"src/hooks/useHasFirstPrediction\";\n\nexport default function Cover4() {\n  useEffect(() => {\n    store.setState({ isCameraEnabled: true });\n  }, []);\n\n  const [state, setState] = useState(0);\n\n  const hasFirstPrediction = useHasFirstPrediction();\n\n  useEffect(() => {\n    setState(0);\n\n    if (hasFirstPrediction) {\n      const timeout1 = setTimeout(() => setState(1), 5000);\n      const timeout2 = setTimeout(() => setState(2), 10000);\n      return () => {\n        clearTimeout(timeout1);\n        clearTimeout(timeout2);\n      };\n    }\n  }, [hasFirstPrediction]);\n\n  const [{ amount }] = useSpring(\n    () => ({\n      amount: state === 1 || state === 2 ? 1 : 0,\n      config: { duration: 5000 },\n    }),\n    [state]\n  );\n\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        width: \"100%\",\n        height: \"100%\",\n      }}\n    >\n      <div style={{ position: \"relative\", width: \"100%\", height: \"100%\" }}>\n        <Canvas orthographic>\n          <WebcamPlane amount={amount} />\n        </Canvas>\n        <div\n          style={{\n            position: \"absolute\",\n            width: \"100%\",\n            padding: \"58px\",\n            top: 0,\n            boxSizing: \"border-box\",\n            textAlign: \"center\",\n          }}\n        >\n          <Text\n            color=\"yellow\"\n            size=\"32px\"\n            style={{\n              textShadow: `0px 4px 4px rgba(0, 0, 0, 0.25)`,\n            }}\n          >\n            {state === 0 && `You don't look happy :(`}\n            {state === 1 && `Let's see what we can do to fix that.`}\n            {state === 2 && `There, much better!`}\n          </Text>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction WebcamPlane({ amount }: { amount: SpringValue<number> }) {\n  const webcam = useStore((state) => state.webcamHTMLElement);\n  const aspect = useStore((state) => state.webcamAspect);\n  const viewport = useThree((state) => state.viewport);\n\n  const ref = useRef<Mesh<BufferGeometry, ShaderMaterial>>();\n  const width = Math.min(viewport.width, viewport.height * aspect);\n  const height = Math.min(viewport.width / aspect, viewport.height);\n\n  const videoTexture = useMemo(() => {\n    return new VideoTexture(webcam);\n  }, [webcam]);\n\n  const predictions = usePredictions();\n\n  useMouthPosition(predictions, ref);\n  useLeftEyePosition(predictions, ref);\n  useRightEyePosition(predictions, ref);\n  useLeftIrisPosition(predictions, ref);\n  useRightIrisPosition(predictions, ref);\n\n  useFrame(() => {\n    if (ref.current) {\n      ref.current.material.uniforms[\"amount\"]!.value = amount.get();\n    }\n  });\n\n  return (\n    <group scale={[width, height, 1]}>\n      <mesh ref={ref}>\n        <planeBufferGeometry />\n        <primitive\n          object={maskMaterial}\n          attach=\"material\"\n          uniforms-map-value={videoTexture}\n          uniforms-mouth-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightEye-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-rightIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-leftIris-value={new Vector4(0.5, 0.5, 0.5, 0.5)}\n          uniforms-amount-value={0}\n        />\n      </mesh>\n    </group>\n  );\n}\n\nfunction useMouthPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [\n    61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 146, 91, 181, 84, 17, 314,\n    405, 321, 375, 291,\n  ];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"mouth\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"mouth\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"mouth\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"mouth\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useLeftEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [225, 228, 189, 128];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightEyePosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const fourPoints: [number, number, number, number] = [445, 448, 413, 357];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(fourPoints, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightEye\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightEye\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightEye\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightEye\"]!.value.w = yMin + 1;\n    }\n  });\n}\nfunction useLeftIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [473, 474, 475, 476, 477];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"leftIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"leftIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"leftIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"leftIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction useRightIrisPosition(\n  predictions: React.MutableRefObject<Predictions[]>,\n  ref: React.MutableRefObject<Mesh<BufferGeometry, ShaderMaterial> | undefined>\n) {\n  const points = [468, 469, 470, 471, 472];\n  useFrame(() => {\n    const prediction = predictions.current[0];\n    if (!prediction) return;\n    const mesh = prediction.scaledMesh as V3[];\n\n    const { xMin, yMax, xMax, yMin } = getBoundingBox(points, mesh);\n\n    if (ref.current?.material !== undefined) {\n      ref.current.material.uniforms[\"rightIris\"]!.value.x = xMin;\n      ref.current.material.uniforms[\"rightIris\"]!.value.y = yMax + 1;\n      ref.current.material.uniforms[\"rightIris\"]!.value.z = xMax;\n      ref.current.material.uniforms[\"rightIris\"]!.value.w = yMin + 1;\n    }\n  });\n}\n\nfunction getBoundingBox(points: number[], mesh: V3[]) {\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  let yMin = Infinity;\n\n  points.forEach((index) => {\n    const [x, y] = mesh[index]!;\n    xMin = Math.min(xMin, x);\n    xMax = Math.max(xMax, x);\n    yMin = Math.min(yMin, y);\n    yMax = Math.max(yMax, y);\n  });\n  return { xMin, yMax, xMax, yMin };\n}\n\nconst vert = /* glsl */ `\nvarying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec3 transformed = vec3( position );\n  vUv = uv.xy;\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * mvPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n`;\n\nconst frag = /* glsl */ `\nvarying vec2 vUv;\nuniform sampler2D map;\nuniform vec4 mouth;\nuniform vec4 leftEye;\nuniform vec4 rightEye;\nuniform vec4 leftIris;\nuniform vec4 rightIris;\nuniform float amount;\n\nvec4 desaturate(vec3 color, float factor)\n{\n\tvec3 lum = vec3(0.299, 0.587, 0.114);\n\tvec3 gray = vec3(dot(lum, color));\n\treturn vec4(mix(color, gray, factor), 1.0);\n}\n\nstruct Result {\n  vec2 uv;\n  float mixDistance;\n};\n\nResult getSmile() {\n  vec2 topLeft = mouth.xy;\n  vec2 bottomRight = mouth.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.2, 0.4)), 0.0, 1.0);\n\n  vec2 center = (topLeft + bottomRight) / 2.0;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n\n  float y = vUv.y - pow(abs(distanceFromCenterLine.x) /3.0, 2.5) * (1.2 - (vUv.y - topLeft.y)/distance.y) * 5.0;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x * 0.5;\n\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\nResult getLeftEye() {\n  vec2 leftIrisCenter = (leftIris.xy + leftIris.zw)/2.0;\n  vec2 topLeft = leftEye.xy;\n  vec2 bottomRight = leftEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = leftIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nResult getRightEye() {\n  vec2 rightIrisCenter = (rightIris.xy + rightIris.zw)/2.0;\n\n  vec2 topLeft = rightEye.xy;\n  vec2 bottomRight = rightEye.zw;\n  vec2 fromTopLeft = vUv - topLeft;\n  vec2 distance = bottomRight - topLeft;\n  vec2 relativeDistance = fromTopLeft / distance;\n  float distanceXFromCenter = abs((relativeDistance.x - 0.5)*2.0);\n\n  float mixDistance = clamp(length((relativeDistance - 0.5)*vec2(1.0, 0.7)), 0.0, 1.0);\n\n  vec2 center = rightIrisCenter;\n  vec2 distanceFromCenterLine = (center - vUv)/distance;\n  float y = vUv.y + distanceFromCenterLine.y*distance.y;\n  float x = vUv.x + distanceFromCenterLine.x*distance.x;\n\n  Result result;\n\n  result.uv = vec2(x, y);\n  result.mixDistance = 1.0 - mixDistance;\n\n  return result;\n}\n\n\nvoid main() {\n    Result smile = getSmile();\n    Result leftEyeKawaii = getLeftEye();\n    Result rightEyeKawaii = getRightEye();\n    vec2 uv = mix(vUv, smile.uv, smile.mixDistance * amount);\n    uv = mix(uv, leftEyeKawaii.uv, leftEyeKawaii.mixDistance * amount);\n    uv = mix(uv, rightEyeKawaii.uv, rightEyeKawaii.mixDistance * amount);\n    vec4 texelColor = texture2D( map, uv );\n    gl_FragColor = desaturate(texelColor.rgb, 1.0 - amount);\n}\n`;\n\nconst maskMaterial = new ShaderMaterial({\n  fragmentShader: frag,\n  vertexShader: vert,\n  transparent: true,\n  uniforms: {\n    map: { value: undefined },\n    mouth: { value: undefined },\n    leftEye: { value: undefined },\n    rightEye: { value: undefined },\n    leftIris: { value: undefined },\n    rightIris: { value: undefined },\n    amount: { value: undefined },\n  },\n});\n"],"sourceRoot":""}